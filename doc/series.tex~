\documentclass{article}
\usepackage{amsmath}

\begin{document}
\section{The series package}

\subsection{Intro}

The series FORM package tries to capture parts of the Mathematica {\tt
  Series} functionality. It implements basic operations on a power
series in one (and at some point maybe even more than one) variable
(e.g. $\epsilon$) up to some cut-off power $\epsilon^{\text{cut}}$. The
supported operations include basic replacements, multiplication of
series and computing a series to some power (including e.g. the inverse and
the square root of the series), where the exponent can be another
series. At the moment, several of these features {\em are turned of},
mostly for performance reasons. It is recommended to use their
standard FORM counterparts instead. 

\subsection{Usage}
\label{sec:usage}

To make the series procedures available, include the header file in your
FORM program:
\begin{verbatim}
#include- series.h
\end{verbatim}

\subsubsection{series}
\label{sec:series}

Before you use any other procedure from the series package, you have to define a global
series variable and a cut-off. This is done with the
procedure {\tt series}. The first parameter is the series variable, the
second one is the highest power of that variable. For example
\begin{verbatim}
#call series(ep,7)
\end{verbatim}
just tells all following procedures that the expressions are series in {\tt
  ep} up to power 7. Note that the {\tt series} procedure itself does
not change expressions or do anything visible.

\subsubsection{power}
\label{sec:pow}

This procedure computes an expression (first argument) to some power
(second argument) and stores the result in some other expression (third
argument). The first two arguments should be expressions and will be
treated as series. This FORM program will compute $(1+ep)^{1+ep}$ up to
the power $ep^3$ and print the result:
\begin{verbatim}
#include- series.h
S ep;
L [1]=1+ep;
L [2]=[1];
#call series(ep,3)
#call power([1],[2],[(1+ep)^(1+ep)])
print [(1+ep)^(1+ep)];
.end
\end{verbatim}

\subsubsection{powerfunction}
\label{sec:pow_fun}

This procedure also computes a series to some power, but works on
functions instead of expressions. The argument of {\tt powerfunction} is
the name of the function, the function's first argument is the base and
the second argument is the exponent. This example will again compute $(1+ep)^{1+ep}$:
\begin{verbatim}
#include- series.h
S ep;
CF pow;
L [1]=pow(1+ep,1+ep);
#call series(ep,3)
#call powerfunction(pow)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.

\subsubsection{log}
\label{sec:log}

{\tt log} computes the logarithm of the first argument (an
expression) and stores it in an expression named like the second
argument. This program will compute $\log (1+ep)$ up to power $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
L [1]=1+ep;
#call series(ep,3)
#call log([1],[log(1+ep)])
print [log(1+ep)];
.end
\end{verbatim}

\subsubsection{logfunction}
\label{sec:log_fun}

This procedure also computes the logarithm of a series, but works on
functions instead of expressions. The argument of {\tt logfunction} is
the name of the logarithm function. This example will again compute $\log(1+ep)$:
\begin{verbatim}
#include- series.h
S ep;
CF log;
L [1]=log(1+ep);
#call series(ep,3)
#call logfunction(log)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.


\subsubsection{exp}
\label{sec:exp}

Like {\tt log} (section~\ref{sec:log}), but computes the
exponential function. Compute $e^{ep}$ up to order $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
L [1]=ep;
#call series(ep,3)
#call exp([1],[exp(ep)])
print [exp(ep)];
.end
\end{verbatim}

\subsubsection{expfunction}
\label{sec:exp_fun}

This procedure also computes the exponential of a series, but works on
functions instead of expressions. The argument of {\tt expfunction} is
the name of the exponential function. This example will again compute $e^{1+ep}$:
\begin{verbatim}
#include- series.h
S ep;
CF exp;
L [1]=exp(1+ep);
#call series(ep,3)
#call expfunction(exp)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.

\subsubsection{invert}
\label{sec:invert}

This procedure inverts a series expression (first argument) and stores
it in the expression given as the second argument. Thus
\begin{verbatim}
#call  invert(series,result)
\end{verbatim}
is equivalent to 
\begin{verbatim}
L [-1]=-1;
#call  invert(series,[-1],result)
drop [-1];
\end{verbatim}
but more readable and faster.

\subsubsection{invertfunction}
\label{sec:inv_fun}

This procedure also computes the inverse of a series, but works on
functions instead of expressions. The argument of {\tt invertfunction} is
the name of the function whose argument is to be inverted. This example will compute $1/(1+ep)$:
\begin{verbatim}
#include- series.h
S ep;
CF den;
L [1]=den(1+ep);
#call series(ep,3)
#call invertfunction(den)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.


\subsection{Implementation}
\label{sec:impl}

This section covers implementation details.

\subsubsection{Generalities}
\label{sec:impl_general}


 We usually want to compute
\begin{equation}
  \label{eq:def}
  f\left(\sum_{i=0}^{\infty}a_i \epsilon^i\right)=\sum_{n=0}^\infty b_i \epsilon^i\,.
\end{equation}
and express the coefficients $b_i$ in terms of the known $a_j$. We can
distinguish between two kinds of formulations: the {\it recursive} representation,
where $b_i$ is a function of $a_j$ and $b_k$ with $k < i$ and the {\it
  explicit} representation, where $b_i$ is a function of the $a_j$ only.
We will usually try to find and use a recursive representation because
it involves a lower number of terms. At the moment, the recursive
representation is used for operations on expressions; for operation
on function arguments ({\tt expfunction, logfunction,...}) I have not yet succeeded in
implementing it and use the explicit representation instead.

The explicit representations make heavy use of partitions.
${\cal P}(n)$ is the set of partitions of $n$ i.e. for any
Partition $P \in {\cal P}(n)$ the sum over all elements of $P$ is
$n$. $|P|$ is the cardinality of $P$.
${\cal M}_P(l)$ is the multiplicity of $l$ in a partition $P$. A simple
example:
\begin{align*}
  {\cal P}(4)=&\{(1,1,1,1),\,(1,1,2),\,(1,3),\,(2,2),\,(4)\}\\
  |(1,1,2)|=&3\\
  {\cal M}_{(1,1,2)}(1)=&2\\
  {\cal M}_{(1,1,2)}(2)=&1\\
\end{align*}
This means e.g. 
\begin{equation}
  \label{eq:exp_ex}
\sum_{P \in {\cal P}(4)} \left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)=
  \frac{c_1^4}{4!}+\frac{c_1^2}{2!}\frac{c_2^1}{1!}+\frac{c_1^1}{1!}\frac{c_3^1}{1!}+\frac{c_2^2}{2!}+\frac{c_4^1}{1!}\,.
\end{equation}


\subsubsection{Exponentiation}
\label{sec:impl_exp}

Exponentiation is required for the evaluation of terms of the form
$\text{series\_1}^{\text{series\_2}}$.
The recursive representation I use is
\begin{align}
  \label{eq:exp_rec}
b_0=&1\\
b_n =&  \sum_{i=1}^{n} \frac{i}{n} a_{i}b_{n-i}
\end{align}

An explicit representation of the $b_i$ is
\begin{equation}
  \label{eq:exp}
  \begin{split}
    b_n=
\sum_{P \in {\cal P}(n)} \left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)
  \end{split}
\end{equation}
For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:impl_general} on
exponentials.



\subsubsection{Logarithms}
\label{sec:impl_log}

Logarithms are also required to compute complicated powers. Here I used
\begin{align}
  \label{eq:log}
\log\left(\sum_{i=k_0}^{\infty}c_i \epsilon^i\right)=&\log\left(a_{k_0}\epsilon^{k_0}\right)+\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)\\
\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)=&\sum_{n=1}^\infty
b_n\epsilon^n\,.
\end{align}
I try to use the following recursive representation of the $b_n$:
\begin{align}
  \label{eq:log_rec}
b_1=&a_1\\
b_n =& a_n - \sum_{i=1}^{n-1} \frac{i}{n} a_{n-i}b_{i}
\end{align}

An explicit representation of the $b_n$ is
\begin{equation}
  \label{eq:log_expl}
  b_n=\left[\sum_{P \in {\cal P}(n)} (-1)^{|P|-1}(|P|-1)!\left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]
\end{equation}
For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:impl_general} on
exponentials.

\subsubsection{Powers}
\label{sec:impl_pow}

Powers $y$ of series $x$ are computed using the formula
\begin{equation}
  \label{eq:pow}
  x^y=\exp(y*log(x))\,.
\end{equation}


\subsubsection{Inverse}
\label{sec:impl_inverse}

Here I use
\begin{align}
  \label{eq:inv}
  \left(\sum_{i=k_0}^{\infty}c_i
    \epsilon^i\right)=c_{k_0}\epsilon^{k_0}\left(1+\sum_{i=1}^{\infty}a_i
    \epsilon^i\right)\\
\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)^{-1}=\sum_{i=0}^{\infty}b_i \epsilon^i
\end{align}
with the recursive representation (for expressions)
\begin{align}
  \label{eq:inv_rec}
  b_0=&1\\
  b_n=&-\sum_{i=0}^{n-1} a_{n-1}b_i 
\end{align}
and the explicit representation (for functions)
\begin{equation}
  \label{eq:inv_expl}
  b_n=\left[\sum_{P \in {\cal P}(n)} (-1)^{|P|}|P|!\left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]
\end{equation}
For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:impl_general} on
exponentials.

\subsection{Deprecated \& development}
\label{sec:depr}

This is a collection of procedures that are not included in the
distribution of the package. They are mostly deprecated or much too
early in the development stage.

\subsubsection{contractpowers}
\label{sec:cpow}

This is a special procedure for simplifying powers like
\begin{verbatim}
(x)^(y/2)*(x)^(y/2)
\end{verbatim}
FORM does not do this automatically - if you encounter such terms, use
\begin{verbatim}
#call contractpowers
\end{verbatim}
While it is certainly useful, this procedure no longer fits with the
rest of the package; it might be included in a different future package.


\subsubsection{Simple Powers}
\label{sec:impl_simpl_pow}

This procedure computes a series to a simple
(i.e. non-series) power. Here the formula
\begin{equation}
  \label{eq:simpl_pow}
  \left(\sum_{i=0}^{\infty}c_i \epsilon^i\right)^j = \sum_{n=0}^\infty
  \left[\sum_{P \in {\cal P}(n)}\left(\prod_{k=0}^{|P|-1}
    (j-k)\right)\left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]\epsilon^n
\end{equation}
is used. For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:exp} on
exponentials. This procedure has performance issues (is slower than {\tt
  power}) and hence is not included.

\subsubsection{Identify}
\label{sec:impl_id}

This procedure is like the usual FORM {\tt id} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.


\subsubsection{Multiply}
\label{sec:impl_multi}

This procedure is like the usual FORM {\tt multiply} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.


\end{document}
