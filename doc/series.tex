\documentclass{article}
\usepackage{amsmath}

\begin{document}
\section{The series package}

\subsection{Intro}

The series FORM package tries to capture parts of the Mathematica {\tt
  Series} functionality. It implements basic operations on a power
series in one (and at some point maybe even more than one) variable
(e.g. $\epsilon$) up to some cut-off power $\epsilon^{\text{cut}}$. The
supported operations include basic replacements, multiplication of
series and computing a series to some power (including e.g. the inverse and
the square root of the series), where the exponent can be another
series. At the moment, several of these features {\em are turned of},
mostly for performance reasons. It is recommended to use their
standard FORM counterparts instead.

\subsection{Quick start}
\label{sec:quick}

This chapter is only for impatient people who do not like reading
manuals. The rest may want to continue with Chapter \ref{sec:usage}.

\begin{verbatim}
*include series package
#include- series.h

S ep;
L foo=1-ep;

*define a series variable and cut
#call series(ep,3)

*invert foo & save result in the new expression bar
#call invert(foo,bar)
* now we have bar=foo^-1+O(ep^4)
drop foo,bar;

* analogous procedures: exp, log, power
* the procedure power(foo,bar,foobar) would compute foobar=foo^bar


*initialise operations on functions
#call init(3)

L foo=exp(1-ep)+exp(1+ep);

*expand exponential  function
#call expand(exp)

*analogous: log, pow, den
* den(x?)=x^-1

.end
\end{verbatim}

\subsection{Usage}
\label{sec:usage}

To make the series procedures available, include the header file in your
FORM program:
\begin{verbatim}
#include- series.h
\end{verbatim}
Make sure that {\tt series.h} resides at some location where FORM will find
it, preferably in one of the directories defined by the environment
variable \mbox{FORMPATH} (see Chapter 1 of the FORM reference manual). The
package tries to interfer as few as possible with the rest of your
program, but there are some caveats:
\begin{itemize}
\item {\tt exp} and {\tt log} are sometimes defined as commuting
  functions inside some of the procedures. Do not misuse these names.
\item Some procedure names are reserved. See also Chapter
  \ref{sec:namesp} on namespaces.
\item Refrain from  using any symbols, expressions, etc. of the form
  {\tt[series::{\it name}]}. They are reserved. Dollar variables {\tt
    \$series{\it name}} are also a bad idea.
\end{itemize}

There are two modes of usage: it is possible to either expand {\em expressions}
(defined with the FORM instructions {\tt local} or {\tt global}) or {\em
  functions}. These modes are very different in nature, both in their
usage and in their internal implementations. 

The first mode, operating on expressions, is more mature and probably
significantly faster. Use this mode, if you can. First, you will want to
call the procedure {\tt series}, e.g.
\begin{verbatim}
#call series(ep,7)
\end{verbatim}
This tells the package to treat all expressions as series in {\tt ep} up
to power 7. After that, you can use one of the procedures {\tt log, exp,
  power} or {\tt invert} with two expression names as arguments to perform the
corresponding operation on the first argument and save the result in the
second argument. See the Chapter \ref{sec:proc} on procedures to find
out which procedure does what.

\medskip

The second mode, operating on functions, is not tested as well and
 a lot slower. In order to use it, you have to call the
procedure {\tt init} first:
\begin{verbatim}
#call init(9)
\end{verbatim}
Its argument is the highest number of terms in a series that will be
computed. If it is set too low, some strange functions can appear in
your expressions. Make sure that the file {\tt partition.tbl} is in your
FORMPATH; this mode will not work if it is not found by FORM.

Like in the first mode, you have to call the {\tt series} procedure
afterwards. In order to compute something, it is most convenient to call {\tt expand} to expand a
function.



\section{Procedures}
\label{sec:proc}


\subsubsection{series}
\label{sec:series}

Before you use any other procedure from the series package, you have to define a global
series variable and a cut-off. This is done with the
procedure {\tt series}. The first parameter is the series variable, the
second one is the highest power of that variable. For example
\begin{verbatim}
#call series(ep,7)
\end{verbatim}
just tells all following procedures that the expressions are series in {\tt
  ep} up to power 7. Note that the {\tt series} procedure itself does
not change expressions or do anything visible.

\subsubsection{power}
\label{sec:pow}

This procedure computes an expression (first argument) to some power
(second argument) and stores the result in some other expression (third
argument). The first two arguments should be expressions and will be
treated as series. This FORM program will compute $(1+ep)^{1+ep}$ up to
the power $ep^3$ and print the result:
\begin{verbatim}
#include- series.h
S ep;
L [1]=1+ep;
L [2]=[1];
#call series(ep,3)
#call power([1],[2],[(1+ep)^(1+ep)])
print [(1+ep)^(1+ep)];
.end
\end{verbatim}


\subsubsection{log}
\label{sec:log}

{\tt log} computes the logarithm of the first argument (an
expression) and stores it in an expression named like the second
argument. This program will compute $\log (1+ep)$ up to power $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
L [1]=1+ep;
#call series(ep,3)
#call log([1],[log(1+ep)])
print [log(1+ep)];
.end
\end{verbatim}



\subsubsection{exp}
\label{sec:exp}

Like {\tt log} (section~\ref{sec:log}), but computes the
exponential function. Compute $e^{ep}$ up to order $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
L [1]=ep;
#call series(ep,3)
#call exp([1],[exp(ep)])
print [exp(ep)];
.end
\end{verbatim}


\subsubsection{invert}
\label{sec:invert}

This procedure inverts a series expression (first argument) and stores
it in the expression given as the second argument. Thus
\begin{verbatim}
#call  invert(series,result)
\end{verbatim}
is equivalent to 
\begin{verbatim}
L [-1]=-1;
#call  power(series,[-1],result)
drop [-1];
\end{verbatim}
but more readable and faster.

\subsubsection{init}
\label{sec:invert}

This procedure initialises operations on functions. If you want to use
{\tt expand} or any of the {\tt *function} procedures, you have to call
this procedure first. Its argument is the highest possible amount of
summands in a series. Depending on the appearance of poles this can be
higher or even lower than your cutting power. (E.g. for a $1/\epsilon$
pole and a cut of $5$ you shold use {\tt \#call init(6)})

\subsubsection{expand}
\label{sec:expand}

Tries to expand the function that is given as an argument. ``Known''
functions are {\tt exp, log, ln, pow, power, den} and {\tt deno} (case sensitive). If
your favourite logarithm function has the name {\tt Log}, try the
procedure {\tt logfunction} instead. This example will compute the
inverse of $1+ep$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF den;
L [1]=den(1+ep);
#call series(ep,3)
#call expand(den)
print [1];
.end
\end{verbatim}

\subsubsection{powerfunction}
\label{sec:pow_fun}

This procedure also computes a series to some power, but works on
functions instead of expressions. The argument of {\tt powerfunction} is
the name of the function, the function's first argument is the base and
the second argument is the exponent. This example will again compute $(1+ep)^{1+ep}$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF pow;
L [1]=pow(1+ep,1+ep);
#call series(ep,3)
#call powerfunction(pow)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.

\subsubsection{logfunction}
\label{sec:log_fun}

This procedure also computes the logarithm of a series, but works on
functions instead of expressions. The argument of {\tt logfunction} is
the name of the logarithm function. This example will again compute $\log(1+ep)$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF log;
L [1]=log(1+ep);
#call series(ep,3)
#call logfunction(log)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.

\subsubsection{expfunction}
\label{sec:exp_fun}

This procedure also computes the exponential of a series, but works on
functions instead of expressions. The argument of {\tt expfunction} is
the name of the exponential function. This example will again compute $e^{1+ep}$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF exp;
L [1]=exp(1+ep);
#call series(ep,3)
#call expfunction(exp)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.

\subsubsection{invertfunction}
\label{sec:inv_fun}

This procedure also computes the inverse of a series, but works on
functions instead of expressions. The argument of {\tt invertfunction} is
the name of the function whose argument is to be inverted. This example will compute $1/(1+ep)$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF den;
L [1]=den(1+ep);
#call series(ep,3)
#call invertfunction(den)
print [1];
.end
\end{verbatim}
Note that this procedure is probably {\it much slower} than its
counterpart which works on expressions. Use it with care and only when needed.

\subsubsection{parallel}
\label{sec:parallel}

Usually parallel processing is turned of for modules containing
procedures which expand functions ({\tt expand, *function}) because of
dollar variables. If you need
parallel computing call the {\tt parallel} procedure {\em directly}
  before the end of the module.

\subsubsection{createtable}
\label{sec:createtable}

For internal use only. Creates a table for storing expressions.

\subsubsection{toseries}
\label{sec:toseries}

For internal use only. Puts an expression into a previously defined table.

\subsubsection{partition}
\label{sec:toseries}

For internal use only. Computes partitions of integer numbers.

\subsection{Namespaces}
\label{sec:namesp}

Unfortunately, FORM has no clean interface for packages: There is no
such thing as namespaces and scoping is (almost) nonexistant. The {\tt
  series} package tries to work around this by assigning very complicated
names for its expressions and symbols, which hopeful no sane person
would ever use in his or her FORM program.

Still, there is a problem with the names of procedures which might clash
with user-defined ones (unfortunately FORM doesn't know overloading
either). To work around this, the {\tt series} package has very basic
support for namespaces. If the preprocessor variable {\tt NAMESPACE} is
defined {\em before} the {\tt series} package is included, all
procedures will have the value of {\tt NAMESPACE} prepended to their name:
\begin{verbatim}
*import the series procedures into the namespace "series"
* DO NOT undefine NAMESPACE
#define NAMESPACE "series"
#include- series.h

L foo=1+ep;
*"series" now becomes "seriesseries"
#call seriesseries(ep,3)

*"exp" becomes "seriesexp"
#call seriesexp(foo,bar)
print bar;
.end
\end{verbatim}

\subsection{Implementation}
\label{sec:impl}

This section covers implementation details. If you just want to use the
package, you can savely stop reading here.

\subsubsection{Generalities}
\label{sec:impl_general}


 We usually want to compute
\begin{equation}
  \label{eq:def}
  f\left(\sum_{i=0}^{\infty}a_i \epsilon^i\right)=\sum_{n=0}^\infty b_i \epsilon^i\,.
\end{equation}
and express the coefficients $b_i$ in terms of the known $a_j$. We can
distinguish between two kinds of formulations: the {\it recursive} representation,
where $b_i$ is a function of $a_j$ and $b_k$ with $k < i$ and the {\it
  explicit} representation, where $b_i$ is a function of the $a_j$ only.
We will usually try to find and use a recursive representation because
it involves a lower number of terms. At the moment, the recursive
representation is used for operations on expressions; for operation
on function arguments ({\tt expfunction, logfunction,...}) I have not yet succeeded in
implementing it and use the explicit representation instead.

The explicit representations make heavy use of partitions.
${\cal P}(n)$ is the set of partitions of $n$ i.e. for any
Partition $P \in {\cal P}(n)$ the sum over all elements of $P$ is
$n$. $|P|$ is the cardinality of $P$.
${\cal M}_P(l)$ is the multiplicity of $l$ in a partition $P$. A simple
example:
\begin{align*}
  {\cal P}(4)=&\{(1,1,1,1),\,(1,1,2),\,(1,3),\,(2,2),\,(4)\}\\
  |(1,1,2)|=&3\\
  {\cal M}_{(1,1,2)}(1)=&2\\
  {\cal M}_{(1,1,2)}(2)=&1\\
\end{align*}
This means e.g. 
\begin{equation}
  \label{eq:exp_ex}
\sum_{P \in {\cal P}(4)} \left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)=
  \frac{c_1^4}{4!}+\frac{c_1^2}{2!}\frac{c_2^1}{1!}+\frac{c_1^1}{1!}\frac{c_3^1}{1!}+\frac{c_2^2}{2!}+\frac{c_4^1}{1!}\,.
\end{equation}


\subsubsection{Exponentiation}
\label{sec:impl_exp}

Exponentiation is required for the evaluation of terms of the form
$\text{series\_1}^{\text{series\_2}}$.
The recursive representation I use is
\begin{align}
  \label{eq:exp_rec}
b_0=&1\\
b_n =&  \sum_{i=1}^{n} \frac{i}{n} a_{i}b_{n-i}
\end{align}

An explicit representation of the $b_i$ is
\begin{equation}
  \label{eq:exp}
  \begin{split}
    b_n=
\sum_{P \in {\cal P}(n)} \left(\prod_{l \in P} \frac{a^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)
  \end{split}
\end{equation}
For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:impl_general} on
exponentials.
 At the moment, however, the function version uses neither of the
 aforementioned formulas but instead just splits the
 exponential function into a product and iteratively replaces
 \begin{equation}
   \label{eq:exp_simple}
   exp(a_n \epsilon^n)=\sum_{i=1}^\infty a_n^i \epsilon^{n\cdot i}
 \end{equation}
up to the required order.


\subsubsection{Logarithms}
\label{sec:impl_log}

Logarithms are also required to compute complicated powers. Here I used
\begin{align}
  \label{eq:log}
\log\left(\sum_{i=k_0}^{\infty}c_i \epsilon^i\right)=&\log\left(a_{k_0}\epsilon^{k_0}\right)+\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)\\
\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)=&\sum_{n=1}^\infty
b_n\epsilon^n\,.
\end{align}
I try to use the following recursive representation of the $b_n$:
\begin{align}
  \label{eq:log_rec}
b_1=&a_1\\
b_n =& a_n - \sum_{i=1}^{n-1} \frac{i}{n} a_{n-i}b_{i}
\end{align}

An explicit representation of the $b_n$ is
\begin{equation}
  \label{eq:log_expl}
  b_n=\left[\sum_{P \in {\cal P}(n)} (-1)^{|P|-1}(|P|-1)!\left(\prod_{l \in P} \frac{a^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]
\end{equation}
For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:impl_general} on
exponentials.

\subsubsection{Powers}
\label{sec:impl_pow}

Powers $y$ of series $x$ are computed using the formula
\begin{equation}
  \label{eq:pow}
  x^y=\exp(y*log(x))\,.
\end{equation}


\subsubsection{Inverse}
\label{sec:impl_inverse}

Here I use
\begin{align}
  \label{eq:inv}
  \left(\sum_{i=k_0}^{\infty}c_i
    \epsilon^i\right)=c_{k_0}\epsilon^{k_0}\left(1+\sum_{i=1}^{\infty}a_i
    \epsilon^i\right)\\
\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)^{-1}=\sum_{i=0}^{\infty}b_i \epsilon^i
\end{align}
with the recursive representation (for expressions)
\begin{align}
  \label{eq:inv_rec}
  b_0=&1\\
  b_n=&-\sum_{i=0}^{n-1} a_{n-1}b_i 
\end{align}
and the explicit representation (for functions)
\begin{equation}
  \label{eq:inv_expl}
  b_n=\left[\sum_{P \in {\cal P}(n)} (-1)^{|P|}|P|!\left(\prod_{l \in P} \frac{a^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]
\end{equation}
For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:impl_general} on
exponentials.

\subsection{Deprecated \& development}
\label{sec:depr}

This is a collection of procedures that are not included in the
distribution of the package. They are mostly deprecated or much too
early in the development stage.


\subsubsection{Simple Powers}
\label{sec:impl_simpl_pow}

This procedure computes a series to a simple
(i.e. non-series) power. Here the formula
\begin{equation}
  \label{eq:simpl_pow}
  \left(\sum_{i=0}^{\infty}c_i \epsilon^i\right)^j = \sum_{n=0}^\infty
  \left[\sum_{P \in {\cal P}(n)}\left(\prod_{k=0}^{|P|-1}
    (j-k)\right)\left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]\epsilon^n
\end{equation}
is used. For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:exp} on
exponentials. This procedure has performance issues (is slower than {\tt
  power}) and hence is not included.

\subsubsection{Identify}
\label{sec:impl_id}

This procedure is like the usual FORM {\tt id} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.


\subsubsection{Multiply}
\label{sec:impl_multi}

This procedure is like the usual FORM {\tt multiply} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.



\end{document}
