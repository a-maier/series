\documentclass[titlepage]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{xcolor}

\lstdefinelanguage{FORM}{%
  morekeywords={cfunction,local,symbol,drop,print,bracket,brackets,keep},
  alsoletter={.,\#},
  otherkeywords={\#call,\#include,.sort,.end},
  sensitive=false,
  morecomment=[l]{**},
  morestring=[b]",
}

\lstset{ %
 language=FORM,
 backgroundcolor=\color{lightgray},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
 basicstyle=\footnotesize\usefont{T1}{DejaVuSansMono-TLF}{m}{n},        % the size of the fonts that are used for the code
 breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
 breaklines=true,                % sets automatic line breaking
 captionpos=t,                    % sets the caption-position to bottom
 commentstyle=\color{red},        % comment style
 deletekeywords={...},            % if you want to delete keywords from the given language
 escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
 extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
 frame=false,                     % adds a frame around the code
 keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
 keywordstyle=\color{blue},       % keyword style
 otherkeywords={},                 % if you want to add more keywords to the set
 numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
 numbersep=5pt,                   % how far the line-numbers are from the code
 rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
 showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
 showstringspaces=false,          % underline spaces within strings only
 showtabs=false,                  % show tabs within strings adding particular underscores
 stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
 stringstyle=\color{gray},         % string literal style
 tabsize=2,                    % sets default tabsize to 2 spaces
 title=\lstname,
 emph={},
 emphstyle=\color{darkgreen},
 postbreak=\mbox{$\hookrightarrow$\space},
 prebreak=\mbox{$\hookrightarrow$},
}

\begin{document}
\title{The \texttt{series} package}
\author{Andreas Maier\\amaier@ifae.es}
\maketitle

\tableofcontents

\section{Intro}

The series FORM package tries to capture parts of the Mathematica {\tt
  Series} functionality. It implements some operations on a power
series in one variable
(e.g. $\epsilon$) up to some cut-off power $\epsilon^{\text{cut}}$. In
the current version the following functions can be expanded:
\begin{itemize}
\item denominators
\item logarithms
\item exponentials
\item series to some power, which can again be a series
\item Gamma functions
\item generic user-defined functions
\end{itemize}
For other basic operations like the multiplication of two series it
is recommended to use the somewhat faster built-in FORM commands.

\subsection{Quick start}
\label{sec:quick}

\begin{lstlisting}
** include series package
#include- series.h # 2.0.0

** optionally change the names for some functions to avoid name clashes
** here we show the default names
** DO NOT ADD ANY SPACE AFTER THE COMMAS
** #call series(setFunctionNames,denominator = den,derivative = D)
** #call series(setFunctionNames,exponential = exp,gamma = Gamma)
** #call series(setFunctionNames,logarithm = log,polygamma = psi)
** #call series(setFunctionNames,power = pow)

** initialisation
#call series(init,50)
symbol ep;

** expand denominators up to (including) ep^3
local denominators = den(1-ep) + den(1+ep);

** for general efficiency, otherwise not really necessary here
bracket den,ep;
.sort
keep brackets;

#call series(expand,den,ep,3)
print+s;
.sort
drop;

** expand exponential function
local exponentials = exp(1-ep) + exp(1+ep);
#call series(expand,exp,ep,3)
print+s;
.sort
cfunction f;
drop;

** analogous: log, Gamma, pow

** expand f(1 + ep + O(ep^3)) in terms of formal derivatives
local fexpanded = f(1-ep) + f(1+ep);
#call series(expand,f,ep,3)
print+s;
.end
\end{lstlisting}

\subsection{Usage}
\label{sec:usage}

To make the series procedures available, include the header file in your
FORM program and specify the version you want:
\begin{lstlisting}
#include- series.h # 2.0.0
\end{lstlisting}
Make sure that {\tt series.h} resides at some location where FORM will find
it, preferably in one of the directories defined by the environment
variable \mbox{FORMPATH} (see Chapter 1 of the FORM reference
manual).

The package tries hard not to interfere with the rest of your
program. The only public procedure is \lstinline!series!. By default, \lstinline!den,D,exp,Gamma,log,psi,pow! are defined as commuting functions. If you this leads to conflicts or you prefer other names you can call

\begin{lstlisting}
#call series(setFunctionNames,denominator = den,derivative = D)
#call series(setFunctionNames,exponential = exp,gamma = Gamma)
#call series(setFunctionNames,logarithm = log,polygamma = psi)
#call series(setFunctionNames,power = pow)
\end{lstlisting}
with different names after the equal signs. It is important to not add
any space after the commas.

Next, set up the package with
\begin{lstlisting}
#call series(init,50)
\end{lstlisting}
The second argument is the highest number of terms in a series that
will be computed. If it is set too low, some strange functions can
appear in your expressions.

There are two modes of usage: it is possible to either expand
\emph{functions} or \emph{expressions} (defined with the FORM
instructions \texttt{local} or \texttt{global}). These modes are very
different in nature, both in their usage and in their internal
implementations.

In order to use the first mode, there are two alternative ways to
expand functions in power series. The first way is to first set an
expansion variable and a cut-off and then call
\lstinline!series(expand,...)! to do the actual expansion:
\begin{lstlisting}
#call series(setExpansion,ep,7)
#call series(expand,f)
#call series(expand,g)
\end{lstlisting}
This is mainly useful when one wants to expand several different functions; it
ensures that everything is expanded consistently in the same variable to
the same power.

Alternatively it is possible to give all information
directly to the expansion:
\begin{lstlisting}
#call series(expand,f,ep,7)
\end{lstlisting}
In this case any existing series specifications will be restored
afterwards:
\begin{lstlisting}
#call series(setExpansion,ep,7)
** expand f in ep up to ep^7
#call series(expand,f)
** expand g in delta up to delta^3
#call series(expand,g,delta,3)
** expand h in ep up to ep^7
#call series(expand,h)
\end{lstlisting}

For functions that are known to \lstinline!expand!, the result will
be computed explicitly. These are most of the functions that can be
renamed with \lstinline!setFunctionNames!, with the exception of the
polygamma and the derivative function.

For the second mode, operating on expressions you will first want to
call the \lstinline!series! procedure with \lstinline!setExpansion!, e.g.
\begin{lstlisting}
#call series(setExpansion,ep,7)
\end{lstlisting}
This tells the package to treat all expressions as series in \texttt{ep} up
to power 7. After that, you can use one of the procedures \lstinline!log, exp, power, invert, Gamma! or \lstinline!wrap! to compute series expansions. For a
description of these procedures and examples see Chapter \ref{sec:proc}.

\section{Procedures}
\label{sec:proc}

The only procedure in the series package is \lstinline!series!. It
accepts the following subprocedure names as second arguments.

\subsubsection{setFunctionNames}
\label{sec:setFunctionNames}

Sets the names of several functions that can appear in the output. If
they are not set by the user, some default function names will be
defined as commuting functions during initialisation. It is therefore
recommended to \emph{call this subprocedure before any others} if you
want to change the defaults.

Each argument after the subprocedure name should have the form
\lstinline!type=name!, \emph{without any leading spaces}. The
supported types and the default names are

\begin{lstlisting}
  denominator = den
  derivative = D
  exponential = exp
  gamma = Gamma
  logarithm = log
  polygamma = psi
  power = pow
\end{lstlisting}

\subsubsection{init}
\label{sec:init}

This subprocedure initialises the package. Its argument is the highest possible amount of
summands in a series. Depending on the appearance of poles this can be
higher or even lower than your cutting power. (E.g. for a $1/\epsilon$
pole and a cut of $5$ you shold use \lstinline!\#call series(init,6)!)

\subsubsection{setExpansion}
\label{sec:setExpansion}

Usually, before you use any other procedure from the series package, you can
define a global series variable and a cut-off. This is done with \lstinline!setExpansion!. The next parameter is the series variable, the
last one is the highest power of that variable. For example
\begin{lstlisting}
#call series(setExpansion,ep,7)
\end{lstlisting}
just tells all following procedures that the expressions are series in {\tt
  ep} up to power 7. Note that the procedure itself does
not change expressions or do anything visible.

\subsection{Procedures operating on functions}
\label{sec:proc_fun}

\subsubsection{expand}
\label{sec:expand}

Tries to expand the function that is given as an argument. See
\ref{sec:setFunctionNames} for the list of known functions. If your
favourite logarithm function has the name {\tt Log}, try the procedure
{\tt expandLog} instead or rename the standard logarithm function as
explained in \ref{sec:setFunctionNames}. If an ``unknown'' function is
given as an argument, the result will be given in terms of symbolic
derivatives of this function.

This example will compute the
inverse of $1+ep$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction den;
local [1] = den(1+ep);
#call series(setExpansion,ep,3)
#call series(expand,den)
** alternative:
** #call series(expand,den,ep,3)
print [1];
.end
\end{lstlisting}

\subsubsection{expandPower}
\label{sec:pow_fun}

This procedure expands power functions $\mathtt{fun(x,y)} = x^y$. The
argument of {\tt expandPower} is the name of the function. This example
will compute $(1+ep)^{1+ep}$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction pow;
local [1] = pow(1+ep,1+ep);
#call series(setExpansion,ep,3)
#call series(expandPower,pow)
print [1];
.end
\end{lstlisting}

\subsubsection{expandLog}
\label{sec:log_fun}

This procedure expands logarithms. The argument of {\tt expandLog} is the name of the
logarithm function. This example will compute $\log(1+ep)$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction log;
local [1] = log(1+ep);
#call series(setExpansion,ep,3)
#call series(expandLog,log)
print [1];
.end
\end{lstlisting}

\subsubsection{expandExp}
\label{sec:exp_fun}

This procedure expands the exponential function. The argument of {\tt
expandExp} is the name of the exponential function. This example will
compute $e^{1+ep}$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction exp;
local [1] = exp(1+ep);
#call series(setExpansion,ep,3)
#call series(expandExp,exp)
print [1];
.end
\end{lstlisting}

\subsubsection{expandDenominator}
\label{sec:inv_fun}

This procedure expands denominators. The argument of {\tt
expandDenominator} is the name of the function whose argument is to be
inverted. This example will compute $1/(1+ep)$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction den;
local [1] = den(1+ep);
#call series(setExpansion,ep,3)
#call series(expandDenominator,den)
print [1];
.end
\end{lstlisting}

\subsubsection{expandGamma}
\label{sec:exp_Gamma}

This procedure expands Gamma functions. The argument of {\tt expandGamma} is
the name of the Gamma function. The expansion will usually contain polygamma
functions denoted as {\tt psi}. No special attention is paid to
poles. It is left to the user to first extract singularities.
This example will compute $\Gamma(1+ep)$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction Gamma;
local [1] = Gamma(1+ep);
#call series(setExpansion,ep,3)
#call series(expandGamma,Gamma)
print [1];
.end
\end{lstlisting}

\subsubsection{expandFunction}
\label{sec:inv_fun}

This procedure expands a generic function. The argument of {\tt
expandDenominator} is the name of the function. The expansion will
contain symbolic derivatives of the function; it is assumed that the
function and its derivatives are regular.
This example will expand $f(1+ep)$ in $ep$:
\begin{lstlisting}
#include- series.h
#call series(setExpansion,3)
symbol ep;
cfunction den;
local [1] = f(1+ep);
#call series(setExpansion,ep,3)
#call series(expandDenominator,den)
print [1];
.end
\end{lstlisting}

\subsubsection{parallel}
\label{sec:parallel}

Usually parallel processing is turned of for modules containing
procedures which expand functions ({\tt expand*}) because of
dollar variables. If you need
parallel computing call the {\tt parallel} procedure {\em directly}
  before the end of the module.

\subsection{Procedures operating on expressions}
\label{sec:proc_expr}

\subsubsection{power}
\label{sec:pow}

This procedure computes an expression (first argument) to some power
(second argument) and stores the result in some other expression (third
argument). The first two arguments should be expressions and will be
treated as series. This FORM program will compute $(1+ep)^{1+ep}$ up to
the power $ep^3$ and print the result:
\begin{lstlisting}
#include- series.h
symbol ep;
local [1]=1+ep;
local [2]=[1];
#call series(setExpansion,ep,3)
#call series(power,[1],[2],[(1+ep)^(1+ep)])
print [(1+ep)^(1+ep)];
.end
\end{lstlisting}


\subsubsection{log}
\label{sec:log}

{\tt log} computes the logarithm of the first argument (an
expression) and stores it in an expression named like the second
argument. This program will compute $\log (1+ep)$ up to power $ep^3$:
\begin{lstlisting}
#include- series.h
symbol ep;
local [1]=1+ep;
#call series(setExpansion,ep,3)
#call series(log,[1],[log(1+ep)])
print [log(1+ep)];
.end
\end{lstlisting}



\subsubsection{exp}
\label{sec:exp}

Like {\tt log} (section~\ref{sec:log}), but computes the
exponential function. Compute $e^{ep}$ up to order $ep^3$:
\begin{lstlisting}
#include- series.h
symbol ep;
local [1]=ep;
#call series(setExpansion,ep,3)
#call series(exp,[1],[exp(ep)])
print [exp(ep)];
.end
\end{lstlisting}


\subsubsection{invert}
\label{sec:invert}

This procedure inverts a series expression (first argument) and stores
it in the expression given as the second argument. Thus
\begin{lstlisting}
#call series( invert,series,result)
\end{lstlisting}
is equivalent to
\begin{lstlisting}
local [-1]=-1;
#call series( power,series,[-1],result)
drop [-1];
\end{lstlisting}
but more readable and faster.

\subsubsection{Gamma}
\label{sec:gamma}

Like {\tt log} (section~\ref{sec:log}), but computes the
Gamma function. The result can contain polygamma functions denoted as
{\tt psi}. Note that no special attention is paid to poles.
Compute $\Gamma(1+ep)$ up to order $ep^3$:
\begin{lstlisting}
#include- series.h
symbol ep;
local [1]=ep;
#call series(setExpansion,ep,3)
#call series(Gamma,[1],[Gamma(1+ep)])
print [Gamma(1+ep)];
.end
\end{lstlisting}


\subsubsection{wrap}
\label{sec:wrap}

This procedure expands a function (second argument) of an expression
(first argument)
and stores it in the expression given as the second argument.
This expands $f(ep)$ up to order $ep^3$:
\begin{lstlisting}
#include- series.h
symbol ep;
cfunction f;
local [1]=ep;
#call series(setExpansion,ep,3)
#call series(wrap,[1],f,[f(ep)])
print [f(ep)];
.end
\end{lstlisting}

\section{Notes on usage}
\label{sec:usage_notes}

\subsection{Laurent series}
\label{sec:laurent}

There are a number of cases where poles in the series expansion are not
treated properly, i.e. where the series expansion is truncated too
early. Here is one example:
\begin{lstlisting}
local foo = power(x-x^2, -1);
#call series(expandPower,power, x, 5)
** bad: exp(-log(x)) * (1+x+...+x^5) misses x^5 term
\end{lstlisting}
Factoring out the pole explicitly fixes the problem:
\begin{lstlisting}
local foo = 1/x*power(1-x, -1);
#call series(expandPower,power, x, 5)
** better: exp(-log(1)) * (1/x+1+x+...+x^5)
\end{lstlisting}
Alternatively, it is of course always possible to use the ``brute
force'' approach and formally expand to some higher order than what is
needed in the end.

Expanding single denominators or products of denominators also works as
expected:
\begin{lstlisting}
local foo = den(x-x^2);
local bar = den(x)*den(1-x);
#call series(expandDenominator,den, x, 5)
** good: (1/x+1+x+...+x^5)
\end{lstlisting}

\subsection{Performance considerations}
\label{sec:perf}

FORM is designed to operate on large expressions and series expansion
can become a major bottleneck. In fact, the naive approach is usually
far from optimal:
\begin{lstlisting}
local foo =
#include- large_expression
;
**bad: this is slow
#call series(expand,`F',ep,`CUT')
\end{lstlisting}
Often, the function `F' will appear in many different terms with the
same arguments so the same work will be done over and over again. It is
then much faster to isolate the expansion variable and the function to
be expanded:
\begin{lstlisting}
local foo =
#include- large_expression
;
**better: only expand each combination ep^x*`F'(?a) once
bracket `F',ep;
.sort
keep brackets;
#call series(expand,`F',ep,`CUT')
\end{lstlisting}
Sometimes it may be even faster to only isolate and expand `F'
itself. In such cases, care should be taken that the expansion is
performed to a sufficiently high order and higher powers of the
expansion variable have to be discarded by hand.
\begin{lstlisting}
local foo =
#include- large_expression
;
**only expand each `F'(?a) once
bracket `F';
.sort
keep brackets;
#call series(expand,`F',ep,{`CUT'+`HighestPoleInCoefficient'})
.sort
if(count(ep,1) > `CUT') discard;
\end{lstlisting}
If products of the function to be expanded appear, it is often
beneficial to combine them into a single function:
\begin{lstlisting}
local foo =
#include- large_expression
;
** combine denominators:
repeat id den(x?)*den(y?) = den(x*y);
bracket den,ep;
.sort
keep brackets;
#call series(expand,den,ep,`CUT')
\end{lstlisting}
Finally, if TFORM is used, terms can be expanded in parallel:
\begin{lstlisting}
local foo =
#include- large_expression
;
**better: only expand each combination ep^x*`F'(?a) once
bracket `F',ep;
.sort
keep brackets;
#call series(expand,`F',ep,`CUT')
** ...maybe more code here ...
#call series(parallel)
.sort
\end{lstlisting}


\appendix

\section{Implementation}
\label{sec:impl}

This section covers implementation details. If you just want to use the
package, you can savely stop reading here.

\subsection{Generalities}
\label{sec:impl_general}


 We usually want to compute
\begin{equation}
  \label{eq:def}
  f\left(\sum_{i=0}^{\infty}a_i \epsilon^i\right)=\sum_{n=0}^\infty b_i \epsilon^i\,.
\end{equation}
and express the coefficients $b_i$ in terms of the known $a_j$. We can
distinguish between two kinds of formulations: the {\it recursive} representation,
where $b_i$ is a function of $a_j$ and $b_k$ with $k < i$ and the {\it
  explicit} representation, where $b_i$ is a function of the $a_j$ only.
The former one turns out to be far more efficient from the
computational point of view. Therefore the procedures in the {\tt
  series} package exclusively use recursive representations.

\subsection{Exponentiation}
\label{sec:impl_exp}

Exponentiation is required for the evaluation of terms of the form
$\text{series\_1}^{\text{series\_2}}$.
The recursive representation I use is
\begin{align}
  \label{eq:exp_rec}
b_0=&1\\
b_n =&  \sum_{i=1}^{n} \frac{i}{n} a_{i}b_{n-i}
\end{align}

In principle one could also split the exponential function into factors
and use the usual series representation up to the required order for
each factor. In tests this has been slower by approximately a factor of fifty.

\subsection{Logarithms}
\label{sec:impl_log}

Logarithms are also required to compute complicated powers. Here I used
\begin{align}
  \label{eq:log}
\log\left(\sum_{i=k_0}^{\infty}c_i \epsilon^i\right)=&\log\left(a_{k_0}\epsilon^{k_0}\right)+\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)\\
\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)=&\sum_{n=1}^\infty
b_n\epsilon^n\,.
\end{align}
I use the following recursive representation of the $b_n$:
\begin{align}
  \label{eq:log_rec}
b_1=&a_1\\
b_n =& a_n - \sum_{i=1}^{n-1} \frac{i}{n} a_{n-i}b_{i}
\end{align}

\subsection{Powers}
\label{sec:impl_pow}

Powers $y$ of series $x$ are computed using the formula
\begin{equation}
  \label{eq:pow}
  x^y=\exp(y*\log(x))\,.
\end{equation}


\subsection{Inverse}
\label{sec:impl_inverse}

Here I use
\begin{align}
  \label{eq:inv}
  \sum_{i=k_0}^{\infty}c_i
    \epsilon^i=c_{k_0}\epsilon^{k_0}\left(1+\sum_{i=1}^{\infty}a_i
    \epsilon^i\right)\\
\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)^{-1}=\sum_{i=0}^{\infty}b_i \epsilon^i
\end{align}
with the recursive representation
\begin{align}
  \label{eq:inv_rec}
  b_0=&1\\
  b_n=&-\sum_{i=0}^{n-1} a_{n-i}b_i \,.
\end{align}

\subsection{Gamma Function}
\label{sec:impl_gamma}

For $-a_0 \notin \mathbb{N}_0$ the series expansion has the following
form:
\begin{equation}
  \label{eq:gamma}
  \Gamma\left(\sum_{i=0}^\infty a_i\epsilon^i\right) =
  \Gamma(a_0)\times\left(1+\sum_{i=1}^\infty b_i\epsilon^i\right)\,.
\end{equation}
The coefficient $b_i$ can be determined by solving
\begin{equation}
  \label{eq:gamma_rec}
  0 = \sum_{P \in \mathcal{P}(i)} \psi_{|P|-1}(a_0)\prod_{l\in
    P}\frac{a_l^{{\cal M}_P(l)}}{{\cal M}_P(l)!}
+ (|P|-1)!\*\prod_{l \in P}\frac{(-b_l)^{{\cal M}_P(l)}}{{\cal M}_P(l)!}\,.
\end{equation}
${\cal P}(i)$ is the set of partitions of $i$ i.e. for any
Partition $P \in {\cal P}(i)$ the sum over all elements of $P$ is
$i$. $|P|$ is the cardinality of $P$.
${\cal M}_P(l)$ is the multiplicity of $l$ in a partition $P$. A simple
example:
\begin{align*}
  {\cal P}(4)=&\{(1,1,1,1),\,(1,1,2),\,(1,3),\,(2,2),\,(4)\}\\
  |(1,1,2)|=&3\\
  {\cal M}_{(1,1,2)}(1)=&2\\
  {\cal M}_{(1,1,2)}(2)=&1\\
\end{align*}
This means e.g.
\begin{equation}
  \label{eq:exp_ex}
\sum_{P \in {\cal P}(4)} \left(\prod_{l \in P} \frac{a^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)=
  \frac{a_1^4}{4!}+\frac{a_1^2}{2!}\frac{a_2^1}{1!}+\frac{a_1^1}{1!}\frac{a_3^1}{1!}+\frac{a_2^2}{2!}+\frac{a_4^1}{1!}\,.
\end{equation}


\subsection{Generic functions}
\label{sec:generic_fun}

Expanding a generic function
\begin{equation}
  \label{eq:generic_fun}
  f\left(\sum_{i=0}^{\infty}a_i
    \epsilon^i\right)=\sum_{i=0}^{\infty}b_i
    \epsilon^i
\end{equation}
only makes sense if there are no poles in the argument.
The $b_i$ are given by
\begin{align}
  \label{eq:generic_rec}
  b_0=&f(a_0)\,,\\
  b_n=&\partial\,\sum_{i=1}^{n}\frac{i}{n} a_{i}b_{n-i} \,,
\end{align}
where $\partial$ only acts on $f$ and
\begin{equation}
  \label{eq:partial}
  \partial^n f(a_0) \equiv f^{(n)}(a_0)
\end{equation}
is the $n-$th derivative of $f$ at $a_0$.

\section{Deprecated \& development}
\label{sec:depr}

This is a collection of components that are not included in the
distribution of the package. They are mostly deprecated or much too
early in the development stage.

\subsection{Explicit representations}

Instead of the recursive representations discussed in
appendix~\ref{sec:impl} also explicit representations could be used.

The explicit representations make heavy use of partitions (see section~\ref{sec:impl_gamma}).
Here is a table with the explicit representations for each operation:


\begin{align}
  &\text{exponential} & b_n=& \sum_{P \in {\cal P}(n)} \left(\prod_{l \in P}
    \frac{a^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)
  \notag\\
  &\text{logarithm} & b_n=&\left[\sum_{P \in {\cal P}(n)}
    (-1)^{|P|-1}(|P|-1)!\left(\prod_{l \in P} \frac{a^{{\cal
            M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]
  \notag\\
  &\text{inverse} & b_n=&\left[\sum_{P \in {\cal P}(n)}
    (-1)^{|P|}|P|!\left(\prod_{l \in P} \frac{a^{{\cal M}_P(l)}_l}{{\cal
          M}_P(l)!} \right)\right]
  \notag\\
  &\text{generic function}& b_n=& \sum_{P \in {\cal P}(n)} \left(\prod_{l \in P}
    \frac{(a_l \;\partial)^{{\cal M}_P(l)}}{{\cal M}_P(l)!}
    f(a_0)\right)
\label{eq:expl}
\end{align}

\subsection{Multivariate series}
\label{sec:multi_var}

In principle one could try to expand not in only one variable, but in
several variables at the same time. In many cases this is, however,
ill-defined --- e.g. it is obviously not possible to expand $1/(x+y)$ in
both $x$ and $y$ at the same time. For sufficiently well-behaved
expressions one could use the formulas for a single variables in slightly
generalised forms.

A convenient shorthand notation when considering $n+1$ expansion variables is to
use tuples
\begin{align}
\label{eq:multivar_conv}
\vec{\epsilon}=&(\epsilon_0,\dots,\epsilon_n), \\
\vec{0}=&(0,\dots,0), \\
\sum_{\vec{\imath}}=&\sum_{i_0}\dots\sum_{i_n}, \\
\vec{\epsilon}^{\;\vec{\imath}} =& \epsilon_0^{i_0 }\cdots\epsilon_n^{i_n}\,.
\end{align}
The recursive expression for expanding
\begin{equation}
  \label{eq:log_multivar}
\log\left(\sum_{\vec{\imath}=\vec{0}}^{\vec{\infty}}a_{\vec{\imath}}\;
 \vec{\epsilon}^{\;\vec{\imath}}\right)=\sum_{\vec{\imath}=\vec{0}}^{\vec{\infty}} b_{\vec{\imath}}\;\vec{\epsilon}^{\;\vec{\imath}}
 \end{equation}
with $a_{\vec{0}}=1$ for example becomes
\begin{align}
  \label{eq:rec_log_multivar}
  b_{\vec{0}}=&0\,,\\
b_{\vec{\imath}}=&a_{\vec{\imath}}+b_{\vec{\imath}}-\sum_{\vec{\jmath}=\vec{0}}^{\vec{\imath}}
\frac{\overline{\imath}}{\overline{n}} a_{\vec{\imath}-\vec{\jmath}} b_{\vec{\jmath}}\,,
 \end{align}
where $\overline{\imath}$ is the arithmetic mean of all elements of the tuple
$\vec{\imath}$. Of course, since only ratios appear, it can also be
interpreted as the sum.

A proof-of-concept implementation for multivariate series exists, but is
not included in the package.

\subsection{Misc procedures}
\label{sec:proc_depr}

\subsubsection{Simple powers}
\label{sec:impl_simpl_pow}

This procedure computes a series to a simple
(i.e. non-series) power. Here the formula
\begin{equation}
  \label{eq:simpl_pow}
  \left(\sum_{i=0}^{\infty}c_i \epsilon^i\right)^j = \sum_{n=0}^\infty
  \left[\sum_{P \in {\cal P}(n)}\left(\prod_{k=0}^{|P|-1}
    (j-k)\right)\left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]\epsilon^n
\end{equation}
is used. For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:exp} on
exponentials. This procedure has performance issues (is slower than {\tt
  power}) and hence is not included.

\subsubsection{Identify}
\label{sec:impl_id}

This procedure is like the usual FORM {\tt id} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.


\subsubsection{Multiply}
\label{sec:impl_multi}

This procedure is like the usual FORM {\tt multiply} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.

\end{document}
