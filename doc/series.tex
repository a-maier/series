\documentclass{article}
\usepackage{amsmath}

\begin{document}
\section{The series package}

\subsection{Intro}

The series FORM package tries to capture parts of the Mathematica {\tt
  Series} functionality. It implements some operations on a power
series in one variable
(e.g. $\epsilon$) up to some cut-off power $\epsilon^{\text{cut}}$. The
supported operations include expanding logarithms, the exponential
function, generic user-defined functions and
 computing a series to some power (including e.g. the inverse and
the square root of the series), where the exponent can be another
series. For other basic operations like multiplication of two series it
is recommended to use the somewhat faster built-in FORM commands.

\subsection{Quick start}
\label{sec:quick}

This section is mainly for impatient people who do not like reading
manuals. The rest may want to continue with section \ref{sec:usage}.

\begin{verbatim}
*include series package
#include- series.h

S ep;
CF f;
L foo=1-ep;

*define a series variable and cut
#call series(ep,3)

*invert foo & save result in the new expression bar
#call invert(foo,bar)
* now we have bar=foo^-1+O(ep^4)

*expand f(foo) & save result in the expression bar
#call wrap(foo,f,bar)

drop foo,bar;

* analogous procedures: exp, log, power
* the procedure power(foo,bar,foobar) would compute foobar=foo^bar


*initialise operations on functions
#call init(3)

L foo=exp(1-ep)+exp(1+ep);

*expand exponential function
#call expand(exp)

*alternative syntax
*#call expand(exp,ep,3)

*analogous: log, pow, den
* den(x?)=x^-1

.end
\end{verbatim}

\subsection{Usage}
\label{sec:usage}

To make the series procedures available, include the header file in your
FORM program:
\begin{verbatim}
#include- series.h
\end{verbatim}
Make sure that {\tt series.h} resides at some location where FORM will find
it, preferably in one of the directories defined by the environment
variable \mbox{FORMPATH} (see Chapter 1 of the FORM reference manual). The
package tries hard not to interfere with the rest of your program, but
there are some caveats:
\begin{itemize}
\item {\tt exp}, {\tt log} and {\tt D} are sometimes defined as commuting
  functions inside some of the procedures. Do not misuse these names.
\item Some procedure names are reserved. See also Chapter
  \ref{sec:namesp} on namespaces.
\item Refrain from  using any symbols, expressions, etc. of the form
  {\tt[series::{\it name}]}. They are reserved. Dollar variables {\tt
    \$series{\it name}} are also a bad idea.
\end{itemize}

There are two modes of usage: it is possible to either expand {\em expressions}
(defined with the FORM instructions {\tt local} or {\tt global}) or {\em
  functions}. These modes are very different in nature, both in their
usage and in their internal implementations.

The first mode, operating on expressions, is more mature.
First, you will want to
call the procedure {\tt series}, e.g.
\begin{verbatim}
#call series(ep,7)
\end{verbatim}
This tells the package to treat all expressions as series in {\tt ep} up
to power 7. After that, you can use one of the procedures {\tt log, exp,
  power, invert} or {\tt wrap} to compute series expansions. For a
description of these procedures and examples see Chapter \ref{sec:proc}.

\medskip

The second mode, operating on functions, is not tested quite as
well. It has been rewritten completely for the latest version and should
now be comparable to the expression mode as far as speed is concerned.
In order to use it, you have to call the procedure {\tt init} first:
\begin{verbatim}
#call init(9)
\end{verbatim}
Its argument is the highest number of terms in a series that will be
computed. If it is set too low, some strange functions can appear in
your expressions.

After the initialisation there are two alternative ways to expand
functions in power series. The first way is to call the {\tt series}
procedure to set an expansion variable and a cut-off and then call
{\tt expand} to do the actual expansion:
\begin{verbatim}
#call series(ep,7)
#call expand(f)
#call expand(g)
\end{verbatim}
This is mainly useful when one wants to expand several different functions; it
ensures that everything is expanded consistently in the same variable to
the same power. Alternatively it is possible to give all information
directly to {\tt expand}:
\begin{verbatim}
#call expand(f,ep,7)
\end{verbatim}

For functions that are known to {\tt expand}, the result will be
computed explicitly. This is the case for denominators ({\tt den,
  deno}), logarithms ({\tt log, ln}), powers ({\tt pow, power}) and the
exponential function ({\tt exp}). For other functions {\tt f} the result
will be given in terms of formal {\tt n}th derivatives {\tt D(f(x),n)}.

\section{Procedures}
\label{sec:proc}


\subsubsection{series}
\label{sec:series}

Before you use any other procedure from the series package, you have to
define a global series variable and a cut-off. This is done with the
procedure {\tt series}. The first parameter is the series variable, the
second one is the highest power of that variable. For example
\begin{verbatim}
#call series(ep,7)
\end{verbatim}
just tells all following procedures that the expressions are series in {\tt
  ep} up to power 7. Note that the {\tt series} procedure itself does
not change expressions or do anything visible.

\subsubsection{power}
\label{sec:pow}

This procedure computes an expression (first argument) to some power
(second argument) and stores the result in some other expression (third
argument). The first two arguments should be expressions and will be
treated as series. This FORM program will compute $(1+ep)^{1+ep}$ up to
the power $ep^3$ and print the result:
\begin{verbatim}
#include- series.h
S ep;
L [1]=1+ep;
L [2]=[1];
#call series(ep,3)
#call power([1],[2],[(1+ep)^(1+ep)])
print [(1+ep)^(1+ep)];
.end
\end{verbatim}


\subsubsection{log}
\label{sec:log}

{\tt log} computes the logarithm of the first argument (an
expression) and stores it in an expression named like the second
argument. This program will compute $\log (1+ep)$ up to power $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
L [1]=1+ep;
#call series(ep,3)
#call log([1],[log(1+ep)])
print [log(1+ep)];
.end
\end{verbatim}



\subsubsection{exp}
\label{sec:exp}

Like {\tt log} (section~\ref{sec:log}), but computes the
exponential function. Compute $e^{ep}$ up to order $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
L [1]=ep;
#call series(ep,3)
#call exp([1],[exp(ep)])
print [exp(ep)];
.end
\end{verbatim}


\subsubsection{invert}
\label{sec:invert}

This procedure inverts a series expression (first argument) and stores
it in the expression given as the second argument. Thus
\begin{verbatim}
#call  invert(series,result)
\end{verbatim}
is equivalent to
\begin{verbatim}
L [-1]=-1;
#call  power(series,[-1],result)
drop [-1];
\end{verbatim}
but more readable and faster.

\subsubsection{wrap}
\label{sec:wrap}

This procedure expands a function (second argument) of an expression
(first argument)
and stores it in the expression given as the second argument.
This expands $f(ep)$ up to order $ep^3$:
\begin{verbatim}
#include- series.h
S ep;
CF f;
L [1]=ep;
#call series(ep,3)
#call wrap([1],f,[f(ep)])
print [f(ep)];
.end
\end{verbatim}

\subsubsection{init}
\label{sec:invert}

This procedure initialises operations on functions. If you want to use
{\tt expand} or any of the {\tt *function} procedures, you have to call
this procedure first. Its argument is the highest possible amount of
summands in a series. Depending on the appearance of poles this can be
higher or even lower than your cutting power. (E.g. for a $1/\epsilon$
pole and a cut of $5$ you shold use {\tt \#call init(6)})

\subsubsection{expand}
\label{sec:expand}

Tries to expand the function that is given as an argument. ``Known''
functions are {\tt exp, log, ln, pow, power, den} and {\tt deno} (case sensitive). If
your favourite logarithm function has the name {\tt Log}, try the
procedure {\tt logfunction} instead. If an ``unknown'' function is given
as an argument, the result will be given in terms of derivatives of this function.

This example will compute the
inverse of $1+ep$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF den;
L [1]=den(1+ep);
#call series(ep,3)
#call expand(den)
*alternative:
*#call expand(den,ep,3)
print [1];
.end
\end{verbatim}

\subsubsection{powerfunction}
\label{sec:pow_fun}

This procedure also computes a series to some power, but works on
functions instead of expressions. The argument of {\tt powerfunction} is
the name of the function, the function's first argument is the base and
the second argument is the exponent. This example will again compute $(1+ep)^{1+ep}$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF pow;
L [1]=pow(1+ep,1+ep);
#call series(ep,3)
#call powerfunction(pow)
print [1];
.end
\end{verbatim}

\subsubsection{logfunction}
\label{sec:log_fun}

This procedure also computes the logarithm of a series, but works on
functions instead of expressions. The argument of {\tt logfunction} is
the name of the logarithm function. This example will again compute $\log(1+ep)$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF log;
L [1]=log(1+ep);
#call series(ep,3)
#call logfunction(log)
print [1];
.end
\end{verbatim}

\subsubsection{expfunction}
\label{sec:exp_fun}

This procedure also computes the exponential of a series, but works on
functions instead of expressions. The argument of {\tt expfunction} is
the name of the exponential function. This example will again compute $e^{1+ep}$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF exp;
L [1]=exp(1+ep);
#call series(ep,3)
#call expfunction(exp)
print [1];
.end
\end{verbatim}

\subsubsection{invertfunction}
\label{sec:inv_fun}

This procedure also computes the inverse of a series, but works on
functions instead of expressions. The argument of {\tt invertfunction} is
the name of the function whose argument is to be inverted. This example will compute $1/(1+ep)$:
\begin{verbatim}
#include- series.h
#call init(3)
S ep;
CF den;
L [1]=den(1+ep);
#call series(ep,3)
#call invertfunction(den)
print [1];
.end
\end{verbatim}

\subsubsection{parallel}
\label{sec:parallel}

Usually parallel processing is turned of for modules containing
procedures which expand functions ({\tt expand, *function}) because of
dollar variables. If you need
parallel computing call the {\tt parallel} procedure {\em directly}
  before the end of the module.

\subsubsection{createtable}
\label{sec:createtable}

For internal use only. Creates a table for storing expressions.

\subsubsection{toseries}
\label{sec:toseries}

For internal use only. Puts an expression into a previously defined table.

\subsection{Namespaces}
\label{sec:namesp}

Unfortunately, FORM has no clean interface for packages: There is no
such thing as namespaces and scoping is (almost) nonexistant. The {\tt
  series} package tries to work around this by assigning very complicated
names for its expressions and symbols, which hopeful no sane person
would ever use in his or her FORM program.

Still, there is a problem with the names of procedures which might clash
with user-defined ones (unfortunately FORM doesn't know overloading
either). To work around this, the {\tt series} package has very basic
support for namespaces. If the preprocessor variable {\tt NAMESPACE} is
defined {\em before} the {\tt series} package is included, all
procedures will have the value of {\tt NAMESPACE} prepended to their name:
\begin{verbatim}
*import the series procedures into the namespace "series"
* DO NOT undefine NAMESPACE
#define NAMESPACE "series"
#include- series.h

L foo=1+ep;
*"series" now becomes "seriesseries"
#call seriesseries(ep,3)

*"exp" becomes "seriesexp"
#call seriesexp(foo,bar)
print bar;
.end
\end{verbatim}

\subsection{Implementation}
\label{sec:impl}

This section covers implementation details. If you just want to use the
package, you can savely stop reading here.

\subsubsection{Generalities}
\label{sec:impl_general}


 We usually want to compute
\begin{equation}
  \label{eq:def}
  f\left(\sum_{i=0}^{\infty}a_i \epsilon^i\right)=\sum_{n=0}^\infty b_i \epsilon^i\,.
\end{equation}
and express the coefficients $b_i$ in terms of the known $a_j$. We can
distinguish between two kinds of formulations: the {\it recursive} representation,
where $b_i$ is a function of $a_j$ and $b_k$ with $k < i$ and the {\it
  explicit} representation, where $b_i$ is a function of the $a_j$ only.
The former one turns out to be far more efficient from the
computational point of view. Therefore the procedures in the {\tt
  series} package exclusively use recursive representations.

\subsubsection{Exponentiation}
\label{sec:impl_exp}

Exponentiation is required for the evaluation of terms of the form
$\text{series\_1}^{\text{series\_2}}$.
The recursive representation I use is
\begin{align}
  \label{eq:exp_rec}
b_0=&1\\
b_n =&  \sum_{i=1}^{n} \frac{i}{n} a_{i}b_{n-i}
\end{align}

In principle one could also split the exponential function into factors
and use the usual series representation up to the required order for
each factor. In tests this has been slower by approximately a factor of fifty.

\subsubsection{Logarithms}
\label{sec:impl_log}

Logarithms are also required to compute complicated powers. Here I used
\begin{align}
  \label{eq:log}
\log\left(\sum_{i=k_0}^{\infty}c_i \epsilon^i\right)=&\log\left(a_{k_0}\epsilon^{k_0}\right)+\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)\\
\log\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)=&\sum_{n=1}^\infty
b_n\epsilon^n\,.
\end{align}
I use the following recursive representation of the $b_n$:
\begin{align}
  \label{eq:log_rec}
b_1=&a_1\\
b_n =& a_n - \sum_{i=1}^{n-1} \frac{i}{n} a_{n-i}b_{i}
\end{align}

\subsubsection{Powers}
\label{sec:impl_pow}

Powers $y$ of series $x$ are computed using the formula
\begin{equation}
  \label{eq:pow}
  x^y=\exp(y*log(x))\,.
\end{equation}


\subsubsection{Inverse}
\label{sec:impl_inverse}

Here I use
\begin{align}
  \label{eq:inv}
  \left(\sum_{i=k_0}^{\infty}c_i
    \epsilon^i\right)=c_{k_0}\epsilon^{k_0}\left(1+\sum_{i=1}^{\infty}a_i
    \epsilon^i\right)\\
\left(1+\sum_{i=1}^{\infty}a_i \epsilon^i\right)^{-1}=\sum_{i=0}^{\infty}b_i \epsilon^i
\end{align}
with the recursive representation
\begin{align}
  \label{eq:inv_rec}
  b_0=&1\\
  b_n=&-\sum_{i=0}^{n-1} a_{n-i}b_i \,.
\end{align}

\subsubsection{Generic functions}
\label{sec:generic_fun}

Expanding a generic function
\begin{equation}
  \label{eq:generic_fun}
  f\left(\sum_{i=0}^{\infty}a_i
    \epsilon^i\right)=\sum_{i=0}^{\infty}b_i
    \epsilon^i
\end{equation}
is only sensible if there are no poles in the argument.
The $b_i$ are given by
\begin{align}
  \label{eq:generic_rec}
  b_0=&f(a_0)\,,\\
  b_n=&\partial\,\sum_{i=1}^{n}\frac{i}{n} a_{i}b_{n-i} \,,
\end{align}
where $\partial$ only acts on $f$ and
\begin{equation}
  \label{eq:partial}
  \partial^n f(a_0) \equiv f^{(n)}(a_0)
\end{equation}
is the $n-$th derivative of $f$ at $a_0$.

\subsection{Deprecated \& development}
\label{sec:depr}

This is a collection of components that are not included in the
distribution of the package. They are mostly deprecated or much too
early in the development stage.

\subsubsection{Explicit representations}

Instead of the recursive representations discussed in
Section~\ref{sec:impl} also explicit representations could be used.

The explicit representations make heavy use of partitions.
${\cal P}(n)$ is the set of partitions of $n$ i.e. for any
Partition $P \in {\cal P}(n)$ the sum over all elements of $P$ is
$n$. $|P|$ is the cardinality of $P$.
${\cal M}_P(l)$ is the multiplicity of $l$ in a partition $P$. A simple
example:
\begin{align*}
  {\cal P}(4)=&\{(1,1,1,1),\,(1,1,2),\,(1,3),\,(2,2),\,(4)\}\\
  |(1,1,2)|=&3\\
  {\cal M}_{(1,1,2)}(1)=&2\\
  {\cal M}_{(1,1,2)}(2)=&1\\
\end{align*}
This means e.g.
\begin{equation}
  \label{eq:exp_ex}
\sum_{P \in {\cal P}(4)} \left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)=
  \frac{c_1^4}{4!}+\frac{c_1^2}{2!}\frac{c_2^1}{1!}+\frac{c_1^1}{1!}\frac{c_3^1}{1!}+\frac{c_2^2}{2!}+\frac{c_4^1}{1!}\,.
\end{equation}
Here is a table with the explicit representations for each operation:


\begin{align}
  &\text{exponential} & b_n=& \sum_{P \in {\cal P}(n)} \left(\prod_{l \in P}
    \frac{a^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)
  \notag\\
  &\text{logarithm} & b_n=&\left[\sum_{P \in {\cal P}(n)}
    (-1)^{|P|-1}(|P|-1)!\left(\prod_{l \in P} \frac{a^{{\cal
            M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]
  \notag\\
  &\text{inverse} & b_n=&\left[\sum_{P \in {\cal P}(n)}
    (-1)^{|P|}|P|!\left(\prod_{l \in P} \frac{a^{{\cal M}_P(l)}_l}{{\cal
          M}_P(l)!} \right)\right]
  \notag\\
  &\text{generic function}& b_n=& \sum_{P \in {\cal P}(n)} \left(\prod_{l \in P}
    \frac{(a_l \;\partial)^{{\cal M}_P(l)}}{{\cal M}_P(l)!}
    f(a_0)\right)
\label{eq:expl}
\end{align}

\subsubsection{Multivariate series}
\label{sec:multi_var}

In principle one could try to expand not in only one variable, but in
several variables at the same time. In many cases this is, however,
ill-defined --- e.g. it is obviously not possible to expand $1/(x+y)$ in
both $x$ and $y$ at the same time. For sufficiently well-behaved
expressions one could use the formulas for a single variables in slightly
generalised forms.

A convenient shorthand notation when considering $n+1$ expansion variables is to
use tuples
\begin{align}
\label{eq:multivar_conv}
\vec{\epsilon}=&(\epsilon_0,\dots,\epsilon_n), \\
\vec{0}=&(0,\dots,0), \\
\sum_{\vec{\imath}}=&\sum_{i_0}\dots\sum_{i_n}, \\
\vec{\epsilon}^{\;\vec{\imath}} =& \epsilon_0^{i_0 }\cdots\epsilon_n^{i_n}\,.
\end{align}
The recursive expression for expanding
\begin{equation}
  \label{eq:log_multivar}
\log\left(\sum_{\vec{\imath}=\vec{0}}^{\vec{\infty}}a_{\vec{\imath}}\;
 \vec{\epsilon}^{\;\vec{\imath}}\right)=\sum_{\vec{\imath}=\vec{0}}^{\vec{\infty}} b_{\vec{\imath}}\;\vec{\epsilon}^{\;\vec{\imath}}
 \end{equation}
with $a_{\vec{0}}=1$ for example becomes
\begin{align}
  \label{eq:rec_log_multivar}
  b_{\vec{0}}=&0\,,\\
b_{\vec{\imath}}=&a_{\vec{\imath}}+b_{\vec{\imath}}-\sum_{\vec{\jmath}=\vec{0}}^{\vec{\imath}}
\frac{\overline{\imath}}{\overline{n}} a_{\vec{\imath}-\vec{\jmath}} b_{\vec{\jmath}}\,,
 \end{align}
where $\overline{\imath}$ is the arithmetic mean of all elements of the tuple
$\vec{\imath}$. Of course, since only ratios appear, it can also be
interpreted as the sum.

A proof-of-concept implementation for multivariate series exists, but is
not included in the package.

\subsubsection{Simple Powers}
\label{sec:impl_simpl_pow}

This procedure computes a series to a simple
(i.e. non-series) power. Here the formula
\begin{equation}
  \label{eq:simpl_pow}
  \left(\sum_{i=0}^{\infty}c_i \epsilon^i\right)^j = \sum_{n=0}^\infty
  \left[\sum_{P \in {\cal P}(n)}\left(\prod_{k=0}^{|P|-1}
    (j-k)\right)\left(\prod_{l \in P} \frac{c^{{\cal M}_P(l)}_l}{{\cal M}_P(l)!} \right)\right]\epsilon^n
\end{equation}
is used. For the definitions of the partition set ${\cal P}$ and the
multiplicity ${\cal M}_P$ see the section \ref{sec:exp} on
exponentials. This procedure has performance issues (is slower than {\tt
  power}) and hence is not included.

\subsubsection{Identify}
\label{sec:impl_id}

This procedure is like the usual FORM {\tt id} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.


\subsubsection{Multiply}
\label{sec:impl_multi}

This procedure is like the usual FORM {\tt multiply} statement, but does not
compute any terms that will be thrown away. Still, it is too slow and
not included in the package.

\end{document}
